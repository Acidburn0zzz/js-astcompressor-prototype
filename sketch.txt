'Table'
  N table entries, referenced elsewhere by 32-bit (?) integral indices
  Some table types have string keys in addition to values. Tables are sorted by key if keys are included (so you can binary search to find by key)
  A table's entries are all the same type, and have a length header. Protobufs or something expressible as protobufs, perhaps?


'String Table'
  String literals keyed by integer. UTF8, deduped.


'Type Table'
  Integer indexed table of Type Definitions. Types have names in individual scopes based on symbols (this allows for imports.)


'Symbol Name'
  Identifier for a symbol. UTF8, deduped (within the scope of a symbol table... maybe globally?). A single symbol can refer to different things in different scopes.


'Symbol Table'
  Lookup table of string key (Symbol Name) to Symbol Definition. Integer indices into this table can be used as shorthand to refer to a symbol.
  A given scope refers to a chain of symbol tables (local symbols, etc) instead of there being one huge symbol table for the executable. i.e. ['module-level symbols', 'type-level symbols', 'function-level symbols']


'Scope'
  Symbol Tables : [Symbol Table id, ...]
    Set of symbol tables for this scope. First one is the global scope, and so on.


'Global Scope'
  Every module has a 'Global Scope' (for simplicity it might just be scope table #0) and everything in the module chains off the Global Scope.


'Member Definition'
  Symbol : Symbol id
    The symbol that names this member, in one of the enclosing scopes.
  Type : Type Definition id
    Type of the member


'Type Definition'
  Category : ?
    Types fall into specific categories. Body of a type definition depends on the category.

    Categories include:
      'AnyAddress'
        Abstract heap address. (Machine int void*, basically)

      'Address'
        Heap address of a known type. (T*)

      'Primitive'
        Built-in value type (bool, int32, float32, etc)

      'Structure'
        Fixed-shape value. Able to exist on the stack/in a local. By-value semantics are guaranteed, but it might end up living on the heap somewhere.

      'Array'
        An array of a homogeneous type (though it can certainly be AnyExternal)

      'FunctionAddress'
        Address of a function with a given signature (think function pointer). Like address, it is implicitly a machine int. Has by-value semantics.

        For example, given a global function ...
          float64 abs (float64 x)
        ... the address of abs (&abs) would be a FunctionAddress with the signature
          float64 (float64).

      'External'
        Known types from the runtime environment with unknown shapes. Converted to a statically known type before use, or passed to functions that accept this type (or AnyExternal). Probably lives on a GC heap or something but doesn't have to. Treat it like void*. Treat as if it has by-reference semantics.
        Individual External types are distinct from each other.

        For example, WebGLBuffer would be an External.

      'FunctionExternal'
        Function from the runtime environment (or another module) with known signature. Might have baggage like an attached closure. Treat as if it has by-reference semantics.

        For example, JS Math.abs would be a FunctionExternal, with the signature ...
          float64 (AnyExternal)

      'AnyExternal'
        Fully untyped version of External. You can convert any External type to AnyExternal.
        This is the equivalent of untyped JS variables.


  AnyAddress
    No body, it's just the machine address type.

  Address
    Type : Type Definition id    

  Primitive
    Put a size in here just for the sake of consistency? Same x86/x64 problem as Structure, though.
    PrimitiveToken : String (UTF8)
      Name of the built-in value type, like int32 or float64.
      There's a fixed set of these names but it's possible to add new ones later (i.e int64).
      For types that can be polyfilled (like a SIMD vector), use Structure.

  Structure
    Size : int
      This could be implied but it's important to ensure that codegen-time expectations map up with run-time.
      What about x86 vs x64, though? Yuck.
    LocalScope : Scope id
    Members : [Member Definition, ...]

    PrimitiveToken : optional String
      Name of a built-in structure type, like 'float32x4'.
      This is an extensibility hook to let you opt-in to special VM types, and polyfill them if they're not available.

  Array
    Type : Type Definition id
    KnownSize : optional int

  FunctionAddress
    Signature : Function Signature id

  External
    No body.

  FunctionExternal
    Signature : Function Signature id

  AnyExternal
    No body.


'Function Signature'
  ReturnType : Type Definition id
    Multiple return values? I think a strongly-typed tuple might be the way to express those.
  ParameterTypes : [Type Definition id, ...]
    Maybe an explicit 'Parameter Definition' type that can encode things like the equivalent of 'T*' or 'ref T'? Not sure it matters enough.


'Symbol Definition'
  Category : ?
    Symbols fall into specific categories. Body of a symbol definition depends on the specific category.

    Type
      Refers to a specific known Type Definition

    Function
      Refers to a specific known Function Definition (known signature, known body)

    FunctionImport
      Refers to a function with a known signature that has its body imported from elsewhere.

    Variable
      A named, mutable value of a known type with persistent storage in the current scope.

    Parameter
      A named, immutable value of a known type. Names one of the current function's arguments.


  Type
    Definition : Type Definition id

  Function
    Definition : Function Definition id

  FunctionImport
    ImportSource : ?
      Where is it being imported from?
    ImportToken : ?
      How is it exported?
    Signature : Function Signature id

  Variable
    Type : Type Definition id

  Parameter
    Type : Type Definition id
    Index : int
      Index of the parameter within the current function's parameter list.


'Function Definition'
  Signature : Function Signature id
    The signature of this function (return type, parameter types).
    Arguments are referred to by ordinal index, not by name (local symbol table assigns names to the parameter indices). This means that two functions with the same type signature but different names have the same signature id.
  LocalScope : Scope id
    Local symbol table + module symbol table etc.
    Local variables are here, local imports (?) are here, then module-level stuff is pulled in.
  Body : Function Body id
    The actual function body. (Putting this at the end of the function definition would make things pretty inconvenient)

  There should be an easy way to extract the name of a function definition. Maybe a convention that all function definitions have at least two scopes, [..., EnclosingScope, LocalScope] and the function name is an index into the EnclosingScope. Or just inline a 'debugger-friendly' name string into the definition so you don't have to pointer-chase?


'Function Body'
  Root : Basic Block Node


'Node'
  Abstract type.


'Argument Node' (Node)
  Abstract type. Nodes that can be passed as arguments to other nodes (operation nodes, invoke nodes, etc).


'Symbol Node' (Argument Node)
  Symbol : Symbol id

  Used to pass symbols to operations - a destination variable, a function to invoke, one of the current function's parameters.


'Literal Node' (Argument Node)
  Type : Type Definition id
  Value : ?

  Used to pass literal values to operations - i.e. the shift amount in a bitshift operation.


'Address Node' (Argument Node)
  Context : Symbol Node
    What this address points into. This is almost certainly the heap.
  Base : Argument Node
    The base address within the context, in elements.
  Offset : Argument Node
    The offset within the context, in elements.
  OffsetMultiplier : Literal Node
    A constant multiplier for Offset.

  Abstract address for pointer and array operations.

  Context[Base + (Offset * OffsetMultiplier)], or
  Context[Base + Offset] for OffsetMultiplier == 1

'Null Node' (Argument Node)
  Represents an omitted optional argument.


'Opcode Definition'
  OpcodeToken : String
    Name of the opcode. This lets us introduce new opcodes later without having to avoid numeric opcode collisions.
  ArgumentCount : int
    Number of arguments this node takes.


'Operation Node' (Node)
  Opcode : Opcode Definition id (byte)
  Arguments : [Argument Node, ...]
    Fixed number of arguments based on ArgumentCount.


'Control Flow Operation Node' (Node)
  Opcode : Opcode Definition id (byte)
  Arguments : [(Argument Node or Basic Block Node), ...]
    Fixed number of arguments based on ArgumentCount.
    These arguments can be either an Argument Node or a Basic Block Node.    


'Invoke Node' (Node)
  Target : Symbol id
    The symbol representing the function being invoked. Should be either a Function or a FunctionImport.
  Result : Symbol id
    The local variable that the result of this invocation will be stored into.
  Arguments : [Argument Node, ...]
    Arguments to the function call. # of arguments is known based on the target.


'Basic Block Node' (Node)
  Nodes : [Node, ...]

  Individual child nodes execute in sequential order.